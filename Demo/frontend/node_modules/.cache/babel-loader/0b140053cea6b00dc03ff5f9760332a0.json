{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _getPrototypeOf = require(\"babel-runtime/core-js/object/get-prototype-of\");\n\nvar _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require(\"babel-runtime/helpers/createClass\");\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _possibleConstructorReturn2 = require(\"babel-runtime/helpers/possibleConstructorReturn\");\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require(\"babel-runtime/helpers/inherits\");\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nvar _underscore = require(\"underscore\");\n\nvar _underscore2 = _interopRequireDefault(_underscore);\n\nvar _immutable = require(\"immutable\");\n\nvar _immutable2 = _interopRequireDefault(_immutable);\n\nvar _event = require(\"./event\");\n\nvar _event2 = _interopRequireDefault(_event);\n\nvar _util = require(\"./base/util\");\n\nvar _util2 = _interopRequireDefault(_util);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * A `TimeRangeEvent` uses a `TimeRange` to specify the range over\n * which the event occurs and maps that to a data object representing\n * some measurements or metrics during that time range.\n *\n * You supply the timerange as a `TimeRange` object.\n *\n * The data is also specified during construction and maybe either:\n *  1) a Javascript object or simple type\n *  2) an Immutable.Map.\n *  3) Simple measurement\n *\n * If an Javascript object is provided it will be stored internally as an\n * Immutable Map. If the data provided is some other simple type (such as an\n * integer) then it will be equivalent to supplying an object of {value: data}.\n * Data may also be undefined.\n *\n * ```\n * const e = new TimeRangeEvent(timerange, data);\n * ```\n *\n * To get the data out of an TimeRangeEvent instance use `data()`.\n * It will return an Immutable.Map. Alternatively you can call `toJSON()`\n * to return a Javascript object representation of the data, while\n * `toString()` will serialize the entire event to a string.\n *\n * **Example:**\n *\n * Given some source of data that looks like this:\n *\n * ```json\n * const event = {\n *     \"start_time\": \"2015-04-22T03:30:00Z\",\n *     \"end_time\": \"2015-04-22T13:00:00Z\",\n *     \"description\": \"At 13:33 pacific circuit 06519 went down.\",\n *     \"title\": \"STAR-CR5 - Outage\",\n *     \"completed\": true,\n *     \"external_ticket\": \"\",\n *     \"esnet_ticket\": \"ESNET-20150421-013\",\n *     \"organization\": \"Internet2 / Level 3\",\n *     \"type\": \"U\"\n * }\n * ```\n *\n * We first extract the begin and end times to build a TimeRange:\n *\n * ```js\n * let b = new Date(event.start_time);\n * let e = new Date(event.end_time);\n * let timerange = new TimeRange(b, e);\n * ```\n *\n * Then we combine the TimeRange and the event itself to create the Event.\n *\n * ```js\n * let outageEvent = new TimeRangeEvent(timerange, sampleEvent);\n * ```\n *\n * Once we have an event we can get access the time range with:\n *\n * ```js\n * outageEvent.begin().getTime()   // 1429673400000\n * outageEvent.end().getTime())    // 1429707600000\n * outageEvent.humanizeDuration()) // \"10 hours\"\n * ```\n *\n * And we can access the data like so:\n *\n * ```js\n * outageEvent.get(\"title\")  // \"STAR-CR5 - Outage\"\n * ```\n */\n\n/*\n *  Copyright (c) 2016-2017, The Regents of the University of California,\n *  through Lawrence Berkeley National Laboratory (subject to receipt\n *  of any required approvals from the U.S. Dept. of Energy).\n *  All rights reserved.\n *\n *  This source code is licensed under the BSD-style license found in the\n *  LICENSE file in the root directory of this source tree.\n */\n\n\nvar TimeRangeEvent = function (_Event) {\n  (0, _inherits3.default)(TimeRangeEvent, _Event);\n  /**\n   * The creation of an TimeRangeEvent is done by combining two parts:\n   * the timerange and the data.\n   *\n   * To construct you specify a TimeRange, along with the data.\n   *\n   * To specify the data you can supply either:\n   *     - a Javascript object containing key values pairs\n   *     - an Immutable.Map, or\n   *     - a simple type such as an integer. In the case of the simple type\n   *       this is a shorthand for supplying {\"value\": v}.\n   */\n\n  function TimeRangeEvent(arg1, arg2) {\n    (0, _classCallCheck3.default)(this, TimeRangeEvent);\n\n    var _this = (0, _possibleConstructorReturn3.default)(this, (TimeRangeEvent.__proto__ || (0, _getPrototypeOf2.default)(TimeRangeEvent)).call(this));\n\n    if (arg1 instanceof TimeRangeEvent) {\n      var other = arg1;\n      _this._d = other._d;\n      return (0, _possibleConstructorReturn3.default)(_this);\n    } else if (arg1 instanceof _immutable2.default.Map) {\n      _this._d = arg1;\n      return (0, _possibleConstructorReturn3.default)(_this);\n    }\n\n    var range = _util2.default.timeRangeFromArg(arg1);\n\n    var data = _util2.default.dataFromArg(arg2);\n\n    _this._d = new _immutable2.default.Map({\n      range: range,\n      data: data\n    });\n    return _this;\n  }\n  /**\n   * Returns the timerange as a string\n   */\n\n\n  (0, _createClass3.default)(TimeRangeEvent, [{\n    key: \"key\",\n    value: function key() {\n      return +this.timerange().begin() + \",\" + +this.timerange().end();\n    }\n    /**\n     * Returns the TimeRangeEvent as a JSON object, converting all\n     * Immutable structures in the process.\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        timerange: this.timerange().toJSON(),\n        data: this.data().toJSON()\n      };\n    }\n    /**\n     * Returns a flat array starting with the timestamp, followed by the values.\n     */\n\n  }, {\n    key: \"toPoint\",\n    value: function toPoint(columns) {\n      var _this2 = this;\n\n      var values = [];\n      columns.forEach(function (c) {\n        var v = _this2.data().get(c);\n\n        values.push(v === \"undefined\" ? null : v);\n      });\n      return [this.timerange().toJSON()].concat(values);\n    }\n    /**\n     * The timerange of this data as a `TimeRange` object\n     * @return {TimeRange} TimeRange of this data.\n     */\n\n  }, {\n    key: \"timerange\",\n    value: function timerange() {\n      return this._d.get(\"range\");\n    }\n    /**\n     * The TimeRange of this event, in UTC, as a string.\n     * @return {string} TimeRange of this data.\n     */\n\n  }, {\n    key: \"timerangeAsUTCString\",\n    value: function timerangeAsUTCString() {\n      return this.timerange().toUTCString();\n    }\n    /**\n     * The TimeRange of this event, in Local time, as a string.\n     * @return {string} TimeRange of this data.\n     */\n\n  }, {\n    key: \"timerangeAsLocalString\",\n    value: function timerangeAsLocalString() {\n      return this.timerange().toLocalString();\n    }\n    /**\n     * The begin time of this Event\n     * @return {Data} Begin time\n     */\n\n  }, {\n    key: \"begin\",\n    value: function begin() {\n      return this.timerange().begin();\n    }\n    /**\n     * The end time of this Event\n     * @return {Data} End time\n     */\n\n  }, {\n    key: \"end\",\n    value: function end() {\n      return this.timerange().end();\n    }\n    /**\n     * Alias for the begin() time.\n     * @return {Data} Time representing this Event\n     */\n\n  }, {\n    key: \"timestamp\",\n    value: function timestamp() {\n      return this.begin();\n    }\n    /**\n     * A human friendly version of the duration of this event\n     */\n\n  }, {\n    key: \"humanizeDuration\",\n    value: function humanizeDuration() {\n      return this.timerange().humanizeDuration();\n    }\n  }]);\n  return TimeRangeEvent;\n}(_event2.default);\n\nexports.default = TimeRangeEvent;","map":null,"metadata":{},"sourceType":"script"}